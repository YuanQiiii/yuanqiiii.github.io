---
title: rust学习笔记
description: 记录学习rust遇到的一些困惑
date: 2025-06-28
tags:
  - rust
---

## day0

### 遮蔽 (Shadowing)

- **定义**：在同一作用域内，使用 `let` 关键字可以声明一个与之前变量同名的新变量，这个新变量会“遮蔽”旧变量。
- **核心优势**:
    1. **允许改变类型**：这是与 `mut` (可变变量) 的最大区别。你可以用一个新类型的变量遮蔽旧变量，非常适合数据转换的场景。

        ```rust
        let spaces = "   ";         // spaces 是 &str 类型
        let spaces = spaces.len(); // spaces 被遮蔽，新变量是 usize 类型
        ```

    2. **维持不可变性**：每次遮蔽都会创建一个新的、默认不可变的变量。这有助于防止在后续代码中意外修改值，增强了代码的安全性。
- **与 Python 的区别**：Rust 的遮蔽是显式的（必须用 `let`），且不会产生 Python 中因隐式创建本地变量而导致的 `UnboundLocalError` 陷阱。

### 代码块作为表达式 (Block as an Expression)

- 在 Rust 中，`{}` 代码块本身可以是一个表达式，能够计算并返回一个值。
- 代码块的返回值是其**最后一行没有分号**的表达式的值。
- 代码块中可以使用`return`关键字，它会立即中断代码块的执行，并返回`return`之后的内容（中断赋值、中断函数）。

    ```rust
    let x = {
        let y = 5;
        y + 1 // 没有分号，表达式的值 6 将作为整个块的返回值
    }; // x 的值现在是 10
    ```

### 变量的内存管理 (Variable Lifetime & Memory Management)

- Rust 遵循 RAII 原则，变量在离开其作用域（`}`）时会被自动“丢弃”(drop)，其资源（如堆内存）会被清理。
  - RAII (Resource Acquisition Is Initialization) 的核心思想： 一个对象在被创建（初始化）时**获取**资源，并在其生命周期结束（被 `drop`）时**释放**资源。
  - **堆内存**：通过 `Box::new`, `String::from`, `vec![]` 等方式在运行时动态分配的内存。
  - **系统资源**：如文件句柄 (`File`)、网络套接字 (`TcpStream`)、互斥锁守卫 (`MutexGuard`) 等。

  - RAII 和 `drop` 规则是为**管理动态资源所有权的运行时对象**而设计的。字符串字面量和常量因为其数据是静态的、内联的，或者说它们根本不“拥有”需要在运行时释放的资源（不在堆上也不在栈上），所以这条规则对它们不适用。这不是规则的“例外”，而是它们从根本上就不符合规则的应用前提。

- 当一个变量被遮蔽后，如果编译器能证明旧的变量再也不会被使用，它**可以立即清理**该变量，而不必等到作用域结束。这是一种编译期优化。

### 类型注解与类型推断 (Annotation vs. Inference)

- **类型推断** (`let a = ...`)：大部分情况下，编译器能根据上下文自动推断出变量的类型。这是 Rust 的默认行为，使代码更简洁。整数默认推断为 `i32`，浮点数默认推断为 `f64`。
- **显式类型注解** (`let a: T = ...`)：当程序员需要明确指定类型时使用。

  - **何时必须使用**：类型有歧义时（如 `parse()`, `collect()`）；创建空数组/集合时；函数签名（函数声明）。
  - **类型注解的优先级高于类型推断**

      ```rust
        let guess: u32 = "42".parse().unwrap();
        let empty_array: [i32; 0] = [];
      ```

  - **何时应该使用**：需要非默认类型时（如 `u8`, `i64`）；增强代码可读性时。

### 单元类型 `()` (The Unit Type)

- 单元类型 `()` 是一个特殊的元组，它没有任何值。它的类型和值都写作 `()`。
- **作用**：在概念上等同于其他语言的 `void`，用于表示“没有信息”或“空返回值”。
- **隐式返回**：如果一个函数或代码块不返回任何其他值，它就隐式地返回单元值 `()`。`fn my_func() {}` 等同于 `fn my_func() -> () {}`。以分号 `;` 结尾的行是一个语句，其值为 `()`。

### 字符 (`char`) 与字符串 (`&str`)

- **单引号 (`'`)** vs. **双引号 (`"`)**：用途完全不同，不能互换。
- **`char` (单引号)**：
  - 代表一个**单个**的 **Unicode 标量值**。
  - 大小固定为 **4 字节**。
  - 示例：`'a'`, `'中'`, `'🚀'`。
- **`&str` (双引号)**：
  - 代表一个**字符串切片**，是对一段 **UTF-8 编码**字节序列的**引用**。
  - 长度不固定，可以包含零个、一个或多个字符。
  - 示例：`""`, `"a"`, `"Hello, 中文!"`。

### 从 `String` 中提取字符

- **核心问题**：`String` 是 UTF-8 **变长**编码，因此不能通过索引 `s[i]` 直接访问字符，这是不安全的。
- **解决方案（迭代）**：

    1. **`.chars()`** (最常用)：返回一个 `char` 的迭代器。可用于遍历或通过 `.nth(n)` 获取第 N 个字符（`O(n)` 复杂度）。

        ```rust
        for c in "你好".chars() {
            println!("{}", c);
        }
        ```

    2. **`.char_indices()`**：当你需要字符及其起始**字节**索引时使用，返回 `(usize, char)` 的迭代器。
    3. **字形簇 (Grapheme Clusters)**：为了处理用户感知的“字符”（如带声调的字母或复合表情符号），应使用 `unicode-segmentation` 这个第三方库的 `.graphemes(true)` 方法。

### 数组 (Arrays)

- 数组的类型签名为 `[T; N]`，其中 `T` 是元素类型，`N` 是固定的长度（编译时常量）。
- `let a: [i32; 5] = [1, 2, 3, 4, 5];` 和 `let a = [1, 2, 3, 4, 5];` 在此例中结果完全相同，前者是显式注解，后者是类型推断。
- 当需要非默认类型（如 `[u8; 5]`）或创建空数组时，必须使用显式类型注解。

## day1

### Rust的核心理念：万物皆表达式

在Rust中，一个非常核心且优雅的设计思想是，几乎所有的东西都是表达式（Expression），这意味着它们都能计算并返回一个值。

- if表达式
  - `if` 在Rust中就是一个表达式，而非传统意义上的语句。因此，我们可以非常方便地在`let`赋值语句中使用它。使用`if`作为表达式时，有一个关键规则：所有的分支（`if`块和`else`块）必须返回相同类型的值，否则编译器会报错。一个`if`表达式的值，就是其被执行的那个分支代码块的值。

- 代码块也是表达式
- 代码块（`{...}`）本身也是一个表达式。一个代码块的值由它内部的最后一行表达式决定。如果这最后一行表达式后面没有分号，那么它的计算结果就是整个代码块的返回值。如果最后一行以分号结尾（使其成为语句），或者代码块为空，那么整个代码块的返回值就是单元类型（unit type）`()`。`if`表达式正是利用了这一特性，它根据条件选择执行某一个代码块，并将那个代码块的值作为自己最终的值。

- 循环作为表达式
  - 循环结构同样遵循表达式的规则，但各有不同。`for`循环和`while`循环也是表达式，但它们的返回值永远是单元类型`()`。与它们不同，`loop`循环是一个特殊的表达式，它可以返回一个具体的值。

  - 从loop循环返回值
    - 由于`loop`被设计为无限循环，它没有“自然结束”的时候，因此不能像普通代码块那样依赖最后一个表达式来返回值。为了从`loop`中取出一个值，必须使用`break`关键字。`break`后面可以跟一个值，这个值就会成为整个`loop`表达式的返回值，例如 `let x = loop { break 42; };`。

  - break的不同形式与返回值
    - `break`关键字本身也有多种形式。当`break`后面直接跟一个值（如`break 10;`），它会中断循环并将这个值作为循环的返回值。如果`break`后面为空（`break;`）或者只跟着一个用于跳出嵌套循环的标签（`break 'label;`），那么它中断的那个循环表达式的返回值就是单元类型`()`。总结来说，只有当`break`明确携带一个值时，`loop`表达式才会返回那个具体的值，否则一律返回`()`。

  - 循环标签的规范
    - 在为循环设置标签（label）时，也有一套规范。语法上，标签必须以单引号`'`作为前缀。而在命名风格上，社区普遍推荐使用简短、有描述性的蛇形命名法（snake_case），例如`'search:`或`'users:`，这样可以清晰地表明循环的用途，尤其是在处理嵌套循环中的`break`或`continue`时，能极大地提高代码的可读性。

## day2

> Rust 内存与所有权

### 三大内存区域

程序中的数据根据其特性被存放在三个不同的区域，理解它们的区别是理解 Rust 的第一步。

| 内存区域 | **栈 (The Stack)** | **堆 (The Heap)** | **静态区 (Static Memory)** |
| :--- | :--- | :--- | :--- |
| **存储内容** | 局部变量 (`i32`, `bool`)、函数参数、指向堆/静态的引用或指针 | 运行时动态创建、大小可变的数据 (`String`, `Vec`) | 编译时就已确定的数据 (字符串字面量、`static`常量) |
| **生命周期** | 短暂，与函数调用绑定，自动回收 | 灵活，由所有权系统管理，所有者离开作用域时回收 | `'static`，与程序共存亡 |
| **管理方式** | 编译器通过移动栈指针自动管理，极快 | Rust 的所有权系统精确管理 (`Drop` Trait) | 编译器写入可执行文件，操作系统加载，程序结束时释放 |
| **核心特性** | LIFO (后进先出)，大小固定，分配速度快 | 大小灵活，分配速度相对较慢，可能产生碎片化 | 大小固定，只读，全局可访问 |

**关键结论**：字符串字面量等静态数据“不会被释放”是正常且安全的设计，因为它们是程序的固有部分，其生命周期与程序本身绑定。

---

### `String` 与 `&str` 的区别

Rust 通过两种字符串类型来清晰地分离“拥有权”和“借用权”。

- **1. `&'static str` (字符串字面量)**
  - **本质**: 一个指向静态内存区域的、不可变的**引用**。
  - **类型**: `&'static str`，其中 `&` 表示引用，`'static` 表示生命周期贯穿程序始终，`str` 表示它指向一个 UTF-8 编码的字节序列。
  - **存储**: 其内容（如 "hello"）硬编码在程序的可执行文件中，加载到静态内存区。
  - **`mut` 的作用**: `let mut s = "..."` 仅表示变量 `s` 这个**绑定**是可变的，可以重新指向另一个字符串字面量，但**不能修改**字面量本身的内容。

- **2. `String` (拥有的字符串)**
  - **本质**: 一个可变的、拥有其数据的、在堆上分配的字符串类型。
  - **内存布局**: 采用“栈 + 堆”的分离式存储：
    - **栈上**：存放一个“控制器”结构，包含指向堆的**指针**、当前**长度 (len)** 和已分配**容量 (capacity)**。
    - **堆上**：存放实际的 UTF-8 文本内容。

  - **`mut` 的作用**: `let mut s = String::from(...)` 允许你调用方法（如 `push_str`）来**修改堆上存储的数据内容**。

- **3. 字符访问**
  - **禁止索引**: Rust **不允许**使用 `s[i]` 的方式访问 `char`，因为 UTF-8 字符是变长的，`i` 无法明确表示是字节还是字符，这会带来安全隐患和隐藏的性能问题。
  - **推荐迭代器**:
    - `.chars()`: 遍历每一个 `char`。
    - `.bytes()`: 遍历每一个原始 `u8` 字节。
    - `.char_indices()`: 同时遍历字节索引和对应的 `char`。

---

### 所有权、移动与复制的核心法则

这是 Rust 最具创新性的部分，也是内存安全的关键。

- **1. 所有权转移 (Move)**

  - **默认行为**: 对于非 `Copy` 类型（如 `String`, `Vec`），**赋值** (`=`)、**函数传参**或**返回**都会导致**所有权转移**。
  - **底层机制**: 一次**按位浅拷贝**（复制栈上的指针和元数据），紧接着**编译器将源变量标记为失效**，以防止对同一份资源的双重所有权和双重释放。
  - **示例**: `let s2 = s1;` 后，`s1` 不再可用。

- **2. `Copy` Trait (轻量级拷贝)**

  - **目的**: 标记那些可以被安全、廉价地进行**按位复制**的类型。
  - **行为**: 对于实现了 `Copy` 的类型，赋值操作会创建一个**完整的、独立的副本**，而**原变量保持有效**。
  - **适用类型**: 完全存储在栈上的简单类型，如 `i32`, `bool`, `char`，以及其所有字段都为 `Copy` 类型的结构体。
  - **实现**: 必须由程序员通过 `#[derive(Copy)]` 显式选择加入。
  - **对于 `i32`**: `let mut x = 5; x = 7;` 是在栈上对 `x` 所在的内存位置进行**原地覆盖**。

- **3. `Clone` Trait (显式深拷贝)**

  - **目的**: 提供一个通用的 `.clone()` 方法，用于创建对象的**显式副本**。
  - **行为**: 对于 `String` 等复杂对象，`.clone()` 通常实现**深拷贝**，即在堆上分配新内存并复制所有数据。这是一个可能**昂贵**的操作。
  - **意图明确**: 在代码中看到 `.clone()`，就意味着一次有意识的、可能消耗资源的复制操作。

- **4. `Copy` 与 `Clone` 的关系**

  - 任何实现了 `Copy` 的类型也**必须**实现 `Clone`。
  - 对于 `Copy` 类型，`.clone()` 方法的实现就是一次简单的按位复制，成本极低。
  - > [!note]
    >
    > ### **`Copy`、`Clone` 与 `Drop` 的铁三角关系**
    >
    > #### **1. “任何实现了 `Copy` 的类型也必须实现 `Clone`” (正确)**
    >
    > 这句论述是完全正确的，其背后是 Rust trait 系统的精心设计。
    >
    > - **语法规定 (Supertrait)**: `Copy` trait 的定义是 `pub trait Copy: Clone {}`。这从语法上就强制规定了 `Clone` 是 `Copy` 的 “supertrait”，即任何想实现 `Copy` 的类型，都必须先满足 `Clone` 的要求。
    >
    > - **概念层级**:
    >
    >   - **`Clone`**: 是一个基础、通用的“可复制”契约。它通过一个显式的 `.clone()` 方法来履行，但不关心复制的成本。
    >
    >   - **`Copy`**: 是一个更强的“可廉价、隐式复制”标记。它声明一个类型的复制操作非常廉价（按位复制），**以至于编译器可以在赋值 (`=`) 时自动、隐式地执行**。
    >
    >   - > [!tip]
    >     >
    >     > > `copy`是为了满足`=`赋值的时候实现拷贝而不是所有权移动，如果没有实现`copy`则会实现所有权移动？
    >     >
    >     > 您这句话以最精炼、最准确的方式概括了 `Copy` trait 的核心作用和 Rust 的默认赋值行为。这正是精髓所在。
    >     >
    >     > 我们可以把这个逻辑看作是 Rust 编译器在处理赋值操作 (`=`) 时的一个内置规则：
    >     >
    >     > **当编译器遇到 `let y = x;` 这行代码时，它会问自己一个问题：**
    >     >
    >     > > “变量 `x` 的类型有没有实现 `Copy` trait？”
    >     >
    >     > 根据这个问题的答案，它会执行以下两种截然不同的操作之
    >     >
    >     > ### **情况一：如果答案是“是” (`x` 的类型实现了 `Copy`)**
    >     >
    >     > - **行为**: **拷贝 (Copy)**。
    >     > - **操作**: 编译器会执行一次廉价的按位复制，将 `x` 在栈上的数据完整地复制一份给 `y`。
    >     > - **结果**: `x` 和 `y` 成为两个完全独立的实例，它们的值相同。最重要的是，**`x` 在赋值后仍然是有效的、可用的。**
    >     > - **适用类型**: `i32`, `bool`, `char`, 以及完全由 `Copy` 类型组成的结构体或元组。
    >     >
    >     > **这就是您说的：“`Copy` 是为了满足 `=` 赋值的时候实现拷贝”。**
    >     >
    >     > ---
    >     >
    >     > ### **情况二：如果答案是“否” (`x` 的类型没有实现 `Copy`)**
    >     >
    >     > - **行为**: **所有权转移 (Move)**。
    >     > - **操作**: 编译器默认执行移动。它同样会执行一次按位复制（将 `x` 在栈上的“控制器”数据复制 `y`），但随后会立即将源变量 **`x` 标记为失效**，禁止后续代码再次使用 `x`。
    >     > - **结果**: `y` 成为了资源新的、唯一的所有者。`x` 不再拥有任何东西，变成了一个“空壳”。
    >     > - **适用类型**: `String`, `Vec`, `Box`, 以及任何拥有堆内存或其他外部资源的、没有实现 `Copy` 的类型。
    >     >
    >     > **这就是您说的：“如果没有实现 `copy` 则会实现所有权移动”。**
    >
    > - **成本澄清**: 很多人会误解“廉价的 `Copy` 为何要依赖可能昂贵的 `Clone`”。关键在于：对于一个 `Copy` 类型，**它的 `.clone()` 方法的实现也同样是廉价的**，其底层操作与按位复制完全相同。
    >
    > - **设计目的**: 这种设计的最大好处是**统一了泛型编程的接口**。无论一个类型是 `String`（非`Copy`）还是 `i32`（`Copy`），只要它实现了 `Clone`，泛型函数就可以通过统一的 `.clone()` 方法来复制它，极大地提高了代码的通用性。
    >
    > #### **2. “通过强制规定‘实现了`Drop`的对象不能实现`copy`’来保证安全” (正确)**
    >
    > 这个总结一针见血，这正是 Rust 杜绝一整类内存安全问题的核心策略。
    >
    > - **黄金法则 (`Copy` 与 `Drop` 互斥)**: Rust 编译器强制执行一条不可逾越的规则——一个类型不能同时实现 `Copy` 和 `Drop` trait。
    > - **逻辑互斥**:
    >   - `Drop` 意味着类型拥有需要特殊清理的外部资源（如堆内存），并且必须在生命周期结束时**亲自、唯一地**执行清理操作。
    >   - `Copy` 意味着类型的实例可以被随意地按位复制，产生多个功能完全相同的副本。
    > - **要解决的问题**: 如果允许一个实现了 `Drop` 的类型被 `Copy`，那么对同一份资源的多个副本（它们拥有相同的指针）在各自离开作用域时都会尝试执行清理操作，这将导致灾难性的**双重释放 (Double Free)**，进而引发内存损坏和悬垂指针。
    > - **Rust 的解决方案**: 通过将这个逻辑矛盾上升为**编译时错误**，Rust 彻底根除了这类在 C/C++ 等语言中属于**运行时 (Runtime) 灾难**的 bug。程序员无需时刻警惕，因为编译器会充当最可靠的守护者，从根本上保证内存安全。

---

### `Copy` 与 `Drop` 的互斥原则

这是防止内存错误的终极防线。

- **`Drop` Trait**: 当一个类型需要自定义的清理逻辑时（如释放堆内存、关闭文件句柄），它会实现 `Drop`。当该类型的所有者离开作用域时，`.drop()` 方法会被自动调用。
- **互斥规则**: Rust 编译器强制规定，**一个类型不能同时实现 `Copy` 和 `Drop`**。
- **原因**: 如果一个实现了 `Drop` 的类型可以被 `Copy`，那么就会产生对同一份资源的多个“所有者”。当这些所有者离开作用域时，每个都会尝试调用 `.drop()` 来清理资源，从而导致**双重释放 (Double Free)**，这是一个灾难性的内存安全漏洞。

### `String::from(&str)` 是否会消耗原始变量？

- **问题**
  - 如果一个 `String` 对象是通过 `String::from(x)` 从一个字符串字面量 `x` 创建的，那么原始的字面量 `x` 会不会因此失效？

- **核心答案**
  - 不会。** 原始的字符串字面量 `x` 在操作后**完全有效**，可以继续使用，其所有权和值都未受任何影响。

- **主要原因解析**

    1. **这是一个“借用”而非“移动”操作**:
        `String::from()` 函数接受的参数类型是 `&str`（一个字符串引用）。在 Rust 中，传递引用是一种**借用（Borrowing）**行为。它只暂时授予函数对数据的“只读访问权”，并不会转移数据的所有权。

    2. **操作的本质是“拷贝数据”**:
        `String::from()` 的内部工作机制是：
        - 通过借用来的引用 `x` 读取其指向的静态数据。
        - 在**堆（Heap）**上分配一块全新的内存。
        - 将静态数据的内容**拷贝**到这块新的堆内存中。
        - 返回一个拥有这份堆上拷贝数据的新 `String` 对象。

    3. **最终状态是“各自独立”**:
        操作完成后，内存中存在两个完全独立且有效的实体：
        - **`x`**: 仍然是一个指向程序**静态内存区**中不可变数据的原始引用。
        - **新创建的 `String`**: 一个**拥有**着堆上一份全新、可变数据的独立对象。

- **核心比喻**
  - 这个过程好比去图书馆将一本**原版书**（`x` 指向的静态数据）拿去**复印**（`String::from` 操作）。你最终得到了一份完全属于你自己的**复印件**（新的 `String` 对象），但图书馆的**原版书**（`x`）丝毫未损，仍然在书架上供他人阅览。

- **结论**
  - `String::from(&str)` 是一个安全的、非破坏性的创建操作。它通过**借用和拷贝**来生成新的自有数据，完全不影响作为数据源的原始变量。

### 可变性与借用规则

在 Rust 中，安全地修改数据依赖于一套严格且在编译期强制执行的规则，这套规则围绕着**所有权 (Ownership)**、**可变性 (Mutability)** 和**借用 (Borrowing)** 构建。

要通过引用来修改一个变量，必须同时满足两个条件：变量本身必须被声明为**可变**的 (`let mut`)，并且创建的引用也必须是**可变引用** (`&mut`)。第一个条件是数据所有者授予修改许可，第二个条件是借用者获取修改权限。两者缺一不可。

```rust
// 正确示例：同时满足两个条件
let mut s = String::from("hello"); // 1. 变量是可变的
let r = &mut s;                     // 2. 引用是可变的
r.push_str(", world");              // 成功修改
println!("{}", s); // 输出: "hello, world"
```

如果变量不是 `mut`，则无法创建 `&mut` 引用，因为数据所有者未授权修改。如果变量是 `mut` 但引用是 `&`（不可变引用），则无法通过该引用修改数据，因为借用者未请求修改权限。这两种情况都会导致编译错误，从而在早期杜绝潜在的程序 bug。

Rust 的借用系统遵循一条黄金法则，以防止数据竞争：在任何一个给定的作用域内，对于一个变量，你只能拥有以下两种状态之一：**要么是一个可变引用 (`&mut T`)，要么是任意数量的不可变引用 (`&T`)**。这两种状态是互斥的，不能共存。这意味着，当一个可变引用存在时，不能有任何其他引用；当存在不可变引用时，不能有任何可变引用。

这条规则带来一个重要的推论：当一个变量被不可变地借用后，它的所有者会被暂时“冻结”。**在所有不可变引用离开作用域之前，你无法通过原始变量直接修改数据。**这是因为不可变引用向使用者做出了一个“数据在此期间不会改变”的承诺，编译器会强制履行这个承诺。

```rust
// 错误示例：当存在不可变引用时，尝试修改所有者
let mut s = String::from("hello");
let r1 = &s; // 不可变借用开始

// s.push_str(", world"); // 编译错误！s 已被不可变地借用，处于“冻结”状态

println!("{}", r1); // 不可变借用在这里仍然有效
```

要修改数据，必须等到所有对它的引用（尤其是不可变引用）都失效（离开作用域）后，所有者才会被“解冻”，从而可以被直接修改或再次被可变地借用。

最后，必须明确区分所有权和引用的概念，尤其是在函数调用中。**引用是对所有权的借用，而不是一种所有权**。将一个值（如 `String`）传递给函数会转移其所有权，导致原变量失效。而将一个引用（如 `&String`）传递给函数只是临时借用，函数执行完毕后，原始数据和引用（如果它在作用域内）依然有效。引用的有效性由其**生命周期和作用域**决定，而非是否被函数使用过。

| 特性 | 所有权 (如 `String`) | 借用/引用 (如 `&String`) |
| :--- | :--- | :--- |
| **本质** | 对数据的完全控制权 | 对数据的临时访问权 |
| **函数传递** | 所有权转移 (Move) | 借用 (Borrow) |
| **传递后原变量状态** | **失效**，不可再用 | **仍然有效** (但可能因借用规则被暂时冻结) |
| **资源释放** | 变量离开作用域时，其拥有的数据被销毁 | 引用离开作用域时，仅引用本身被销毁，不影响原始数据 |

总而言之，Rust 的这套机制通过在编译阶段施加严格的限制，从根本上消除了数据竞争等并发问题，换来了极高的运行时安全性和程序可靠性。

## day3

### 引用与切片

**关于切片 (Slices)**

切片 (Slice) 是对集合中部分数据的一个轻量级视图，它不持有数据所有权。切片可以是不可变的 (`&[T]`)，提供只读访问；也可以是可变的 (`&mut [T]`)，提供读写访问。切片是一个通用概念，适用于任何拥有连续内存布局的数据结构，如数组 (`Array`)、向量 (`Vec<T>`) 以及字符串 (`String`)。字符串切片的类型是 `&str`。

**切片与 UTF-8 安全性**

Rust 的 `String` 和 `&str` 内部使用变长的 UTF-8 编码。字符串切片的索引 `&s[start..end]` 是基于字节的，这保证了 `O(1)` 的访问性能。为了确保数据正确性，Rust 会在创建切片时进行运行时检查。如果切片的起始或结束字节位置没有落在合法的 UTF-8 字符边界上（比如将一个多字节字符从中间截断），程序会立即 `panic`。这种“快速失败”的设计，从根本上杜绝了无效字符串切片的产生。

**引用的基本规则（借用）**

Rust 通过借用规则来保证内存安全，核心思想是“读写互斥”。在任何一个作用域内，对于同一份数据，你只能选择以下两种情况之一：

1. 拥有任意数量的不可变引用 (`&T`)，即允许多个“读者”。

2. 拥有一个且仅有一个可变引用 (&mut T)，即只允许一个“写者”。

   当存在任何不可变引用时，数据不能被修改。当存在一个可变引用时，不能存在其他任何引用。

**不可变引用的传递与生命周期**

从一个不可变引用创建另一个不可变引用是完全允许的，因为它符合“允许多个读者”的规则。

- **创建 vs 复制**：`let r1 = &data;` 是向 `data` **创建**一个新的借用，需要接受借用检查器的检查。而 `let r2 = r1;` 或将 `r1` 作为函数参数传递，则是对 `r1` 这个引用的**复制**（因为 `&T` 是 `Copy` 类型），这个操作非常轻量，它只是复制了指向数据的内存地址。函数返回一个引用则是将引用的所有权**移动**出函数。
- **失效时机**：引用并非只在超出词法作用域（大括号）时才失效。更精确地说，引用在其**生命周期结束**时失效。得益于非词法作用域生命周期（NLL），一个引用的生命周期会持续到它在代码中**最后一次被使用**的地方。这意味着，即使从代码文本上看还在作用域内，但如果一个引用后续不再被使用，它的借用就会提前结束，从而允许创建冲突的引用（如可变引用）。

**核心行为总结**

| 行为               | 底层机制                     |
| ------------------ | ---------------------------- |
| `let r1 = &data;`  | 创建新借用 (Create Borrow)   |
| `let r2 = r1;`     | 复制引用 (Copy Reference)    |
| `my_function(r1);` | 复制引用 (Copy Reference)    |
| `return r1;`       | 移动引用 (Move Reference)    |
| 引用失效           | 生命周期结束 (Lifetime Ends) |
